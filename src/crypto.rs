//! Minimal cryptographic helpers for prototype purposes.
//!
//! This module currently exposes a simple Ed25519 keypair generator and thin
//! wrappers around BLAKE3 so that higher layers can be wired without committing
//! to a final cryptographic design. The implementation should be revisited once
//! the networking and consensus layers impose stronger requirements (hardware
//! wallets, VRF, multisignatures, etc.).
//!
//!
use crate::random;
use base64::prelude::*;
pub use blake3::Hash as Blake3Hash;
use chacha20poly1305::{
    Key, XChaCha20Poly1305, XNonce,
    aead::{Aead, KeyInit},
};
use ed25519_dalek::{SigningKey, VerifyingKey};
use rand_core::RngCore;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;
use zeroize::Zeroize;

// Nonce Length for XChaCha20Poly1305
const NONCE_LEN: usize = 24;

/// Default filename for encrypted signing keys
pub const SECRET_KEY_FILE: &str = "secret.json";

/// Structure for serializing encrypted secret key to JSON
#[derive(Serialize, Deserialize)]
struct SecretFile {
    nonce: String, // base64-encoded nonce
    enc: String,   // base64-encoded ciphertext
}

/// Generates an Ed25519 keypair using the thread-local cryptographic RNG.
pub fn generate_keypair() -> (VerifyingKey, SigningKey) {
    let mut rng = random::crypto_rng();
    let signing = SigningKey::generate(&mut rng);
    let verifying = signing.verifying_key();
    (verifying, signing)
}

/// Computes the BLAKE3 hash of `input`.
pub fn blake3_hash(input: &[u8]) -> Blake3Hash {
    blake3::hash(input)
}

/// Derives a 32-byte encryption key from a passphrase
fn key_from_passphrase(passphrase: &str) -> Key {
    let digest = blake3_hash(passphrase.as_bytes());
    // Key::from_slice returns a reference; clone to produce an owned Key
    Key::from(*digest.as_bytes())
}

/// Encrypts and writes a signing key to a JSON file using XChaCha20Poly1305.
/// File format: JSON with base64-encoded nonce and ciphertext.
pub fn write_signing_key_to_file(
    signing_key: &SigningKey,
    path: &Path,
    passphrase: &str,
) -> anyhow::Result<()> {
    let mut rng = random::crypto_rng();

    // Generate a random nonce for ChaCha20Poly1305 encryption
    let mut nonce_bytes = [0u8; NONCE_LEN];

    rng.fill_bytes(&mut nonce_bytes);

    // Derive encryption key from passphrase and salt
    let key = key_from_passphrase(passphrase);

    // Create ChaCha20Poly1305 cipher instance
    let cipher = XChaCha20Poly1305::new(&key);
    // Create nonce from generated bytes
    let nonce = XNonce::from_slice(&nonce_bytes);
    // Encrypt the signing key bytes with the derived key and nonce
    let ciphertext = cipher
        .encrypt(nonce, signing_key.to_bytes().as_ref())
        .map_err(|_| anyhow::anyhow!("encryption failed"))?;

    // Zeroize key material
    let mut key_bytes: [u8; 32] = *key.as_ref();
    key_bytes.zeroize();

    // Serialize nonce and ciphertext to JSON and write to file
    let secret_file = SecretFile {
        nonce: BASE64_STANDARD.encode(&nonce_bytes),
        enc: BASE64_STANDARD.encode(&ciphertext),
    };

    let json_content = serde_json::to_string_pretty(&secret_file)?;
    fs::write(path, json_content)?;

    Ok(())
}

/// Reads and decrypts a signing key from a file. Returns an error if the passphrase is incorrect
/// or if the file is corrupted.
pub fn read_signing_key_from_file(path: &Path, passphrase: &str) -> anyhow::Result<SigningKey> {
    let file_content = std::fs::read(path)?;
    // desirialize JSON content
    let secret_file: SecretFile =
        serde_json::from_slice(&file_content).map_err(|_| anyhow::anyhow!("failed to parse JSON"))?;
    // Decode base64 nonce and ciphertext
    let nonce_bytes = BASE64_STANDARD
        .decode(secret_file.nonce)
        .map_err(|_| anyhow::anyhow!("invalid base64 nonce"))?;
    // Check nonce length
    if nonce_bytes.len() != NONCE_LEN {
        anyhow::bail!("invalid nonce length: expected {}, got {}", NONCE_LEN, nonce_bytes.len());
    }
    // Decode ciphertext
    let ciphertext = BASE64_STANDARD
        .decode(secret_file.enc)
        .map_err(|_| anyhow::anyhow!("invalid base64 ciphertext"))?;

    // Derive encryption key from passphrase and salt
    let key = key_from_passphrase(passphrase); // Clear
    // Create ChaCha20Poly1305 cipher instance
    let cipher = XChaCha20Poly1305::new(&key);
    // Create nonce from decoded bytes
    let nonce = XNonce::from_slice(&nonce_bytes);
    // Decrypt the signing key bytes with nonce and derived key
    let plaintext = cipher
        .decrypt(nonce, ciphertext.as_ref())
        .map_err(|_| anyhow::anyhow!("decryption failed (incorrect passphrase or corrupted file)"))?;

    // Zeroize key material
    let mut key_bytes: [u8; 32] = *key.as_ref();
    key_bytes.zeroize();

    // Expect a 32-byte Ed25519 signing key; convert from slice to array.
    let sk_bytes: [u8; 32] = plaintext.as_slice().try_into().map_err(|_| anyhow::anyhow!("invalid key length after decryption"))?;

    Ok(SigningKey::from_bytes(&sk_bytes))
}

#[cfg(test)]
mod tests {
    use super::*;
    use ed25519_dalek::{Signer, Verifier};

    #[test]
    fn generate_keypair_produces_unique_keys() {
        let (pub1, sec1) = generate_keypair();
        let (pub2, sec2) = generate_keypair();
        assert_ne!(
            pub1.to_bytes(),
            pub2.to_bytes(),
            "public keys should differ"
        );
        assert_ne!(
            sec1.to_bytes(),
            sec2.to_bytes(),
            "secret keys should differ"
        );
    }

    #[test]
    fn signing_and_verifying_round_trip() {
        let (public, private) = generate_keypair();
        let message = b"crit signing test";

        let signature = private.sign(message);
        public
            .verify(message, &signature)
            .expect("signature should verify");
    }

    #[test]
    fn signature_verification_fails_on_modified_message() {
        let (public, private) = generate_keypair();
        let signature = private.sign(b"original message");

        assert!(
            public.verify(b"tampered message", &signature).is_err(),
            "verification should fail on modified message"
        );
    }

    #[test]
    fn signature_verification_fails_on_modified_signature() {
        let (public, private) = generate_keypair();
        let mut signature = private.sign(b"crit mod sig").to_bytes();

        // Flip a bit in the signature to simulate tampering.
        signature[0] ^= 0x01;
        let tampered = ed25519_dalek::Signature::from_bytes(&signature);
        assert!(
            public.verify(b"crit mod sig", &tampered).is_err(),
            "verification should fail when the signature is tampered"
        );
    }

    #[test]
    fn signature_verification_fails_on_wrong_public_key() {
        let (_public1, private1) = generate_keypair();
        let (public2, _) = generate_keypair();
        let signature = private1.sign(b"crit wrong key");

        assert!(
            public2.verify(b"crit wrong key", &signature).is_err(),
            "verification should fail with a different public key"
        );
    }

    #[test]
    fn blake3_helpers_return_consistent_results() {
        let input = b"crit hashing";
        let hash = blake3_hash(input);
        let digest: [u8; 32] = *hash.as_bytes();
        assert_eq!(hash.as_bytes(), &digest);
    }

    #[test]
    fn encrypt_decrypt_signing_key_round_trip() {
        use std::fs;
        use std::path::PathBuf;

        let (_verifying, signing_key) = generate_keypair();
        let passphrase = "strong_password";

        let temp_path = PathBuf::from("/tmp/encrypted_key.json");

        write_signing_key_to_file(&signing_key, &temp_path, passphrase)
            .expect("should write encrypted key");

        let decrypted_key =
            read_signing_key_from_file(&temp_path, passphrase).expect("should read encrypted key");

        assert_eq!(
            signing_key.to_bytes(),
            decrypted_key.to_bytes(),
            "decrypted key should match original"
        );

        fs::remove_file(&temp_path).ok();
    }

    #[test]
    fn decrypt_with_wrong_passphrase_fails() {
        use std::fs;
        use std::path::PathBuf;

        let (_verifying, signing_key) = generate_keypair();
        let correct_passphrase = "correct_password";
        let wrong_passphrase = "wrong_password";

        let temp_path = PathBuf::from("/tmp/decript_encrypted_key.json");

        write_signing_key_to_file(&signing_key, &temp_path, correct_passphrase)
            .expect("should write encrypted key");

        let result = read_signing_key_from_file(&temp_path, wrong_passphrase);

        if let Err(e) = result {
            assert!(e.to_string().contains("incorrect passphrase"));
        } else {
            panic!("decryption should fail with wrong passphrase");
        }
        fs::remove_file(&temp_path).ok();
    }

    #[test]
    fn decrypt_with_tampered_file_fails() {
        use std::fs;
        use std::path::PathBuf;

        let (_verifying, signing_key) = generate_keypair();
        let passphrase = "secure_password";

        let temp_path = PathBuf::from("/tmp/tampered_encrypted_key.json");

        write_signing_key_to_file(&signing_key, &temp_path, passphrase)
            .expect("should write encrypted key");

        // Tamper with the file by flipping a byte
        let mut file_content = fs::read(&temp_path).expect("should read file");
        file_content[20] ^= 0xFF; // Flip a byte in the ciphertext
        fs::write(&temp_path, &file_content).expect("should write tampered file");

        let result = read_signing_key_from_file(&temp_path, passphrase);

        assert!(result.is_err(), "decryption should fail with tampered file");

        fs::remove_file(&temp_path).ok();
    }

}
